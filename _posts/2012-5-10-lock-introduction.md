---
layout: post
title: 锁
description: 在并发环境下，通常需要一些机制来保证数据在操作过程中，不会被外界修改，这样的机制就叫做“锁”。
tags: 后端
---

在并发环境下，通常需要一些机制来保证数据在操作过程中，不会被外界修改，这样的机制就叫做“锁”。

锁通常有两种经典的实现：

* 悲观锁（Pessimistic Concurrency Control, PCC）
* 乐观锁（Optimistic Concurrency Control, PCC）

## **悲观锁**

悲观锁是一种非常典型且非常严格的并发控制策略。悲观锁有强烈的独占和排他特性，能够有效地避免不同事务对同一数据并发更新而造成的数据一致性问题。

### **实现机制**

在悲观锁地实现原理中，如果一个事务正在对某一数据进行处理，那么在整个处理过程中，都会将该数据处于锁定状态，其他事务都无法对该数据进行处理，直到该事务完成对该数据地处理，
释放了对应地锁之后，其他事务才能够重新竞争来对该数据进行更新操作。

也就是说，对于一份独立的数据，系统是分配了一把唯一的钥匙，谁获得了这把钥匙，谁就可以去开启这把锁，获得更新这份数据的权利。

### **适用场景**

悲观锁的策略适合解决那些对于数据更新竞争十分激烈的场景。

## **乐观锁**

乐观锁也是一种常见的并发控制策略。

### **与乐观锁的不同点**

相对于悲观锁，乐观锁机制显得更加宽松和友好。

悲观锁假定不同事务之间的处理一定会出现相互干扰，从而需要在一个事务从头到位的过程中，都对数据进行加锁处理。

而乐观锁正好相反，它假定多个事务在处理过程中不会相互干扰，因此在事务处理的大部分时间里，都不需要对数据进行加锁处理。

### **实现机制**

既然有并发，就一定存在数据更新冲突的可能。

在乐观锁机制中，再更新请求提交之前，每个事务都会首先检查当前事务读取数据后，是否有其他事务对该数据进行了修改。如果其他事务有更新的话，那么正在提交的事务就需要回滚。

其中检查其他事务是否有更新这个步骤是乐观锁实现机制的关键，这部分最典型的实现是“CAS”。

### **适用场景**

乐观锁通常适合使用在数据并发竞争不大、事务冲突较少的应用场景中。